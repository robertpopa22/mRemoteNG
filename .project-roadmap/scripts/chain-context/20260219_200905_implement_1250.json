{
  "task_type": "implement",
  "task_id": "1250",
  "started_at": "2026-02-19T19:46:25",
  "finished_at": "2026-02-19T20:09:05",
  "attempts": [
    {
      "agent": "codex",
      "task": "implement #1250",
      "success": false,
      "result": null,
      "raw_output": "",
      "errors": "Agent returned None after retries",
      "files_modified": [],
      "build_result": null,
      "test_result": null,
      "timed_out": false,
      "diff_summary": null,
      "timestamp": "2026-02-19T19:46:25"
    },
    {
      "agent": "gemini",
      "task": "implement #1250",
      "success": false,
      "result": null,
      "raw_output": "",
      "errors": "Agent returned None after retries",
      "files_modified": [],
      "build_result": null,
      "test_result": null,
      "timed_out": false,
      "diff_summary": null,
      "timestamp": "2026-02-19T19:58:55"
    },
    {
      "agent": "claude",
      "task": "implement #1250",
      "success": false,
      "result": null,
      "raw_output": "",
      "errors": "TIMEOUT after 600s",
      "files_modified": [
        ".project-roadmap/issues-db/upstream/1250.json",
        ".project-roadmap/scripts/chain-context/_timeout_history.json",
        "mRemoteNG/Config/Serializers/ConnectionSerializers/Xml/XmlConnectionsDocumentCompiler.cs",
        "mRemoteNG/Connection/ConnectionInitiator.cs",
        "mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs",
        "mRemoteNG/Tree/Smart/ConnectedGroupNode.cs",
        "mRemoteNG/Tree/Smart/RecentGroupNode.cs",
        "mRemoteNG/Tree/Smart/SmartConnectionInfo.cs",
        "mRemoteNG/Tree/Smart/SmartGroupRoot.cs",
        "mRemoteNG/UI/Controls/ConnectionContextMenu.cs",
        "mRemoteNG/UI/Controls/ConnectionTree/ConnectionTree.cs"
      ],
      "build_result": null,
      "test_result": null,
      "timed_out": true,
      "diff_summary": ".project-roadmap/issues-db/upstream/1250.json      |  15 +++-\n .../scripts/chain-context/_timeout_history.json    |   4 +-\n .../Xml/XmlConnectionsDocumentCompiler.cs          |   4 +\n mRemoteNG/Connection/ConnectionInitiator.cs        |   8 ++\n mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs |  16 +++-\n mRemoteNG/Tree/Smart/ConnectedGroupNode.cs         | 100 ++++++++-------------\n mRemoteNG/Tree/Smart/RecentGroupNode.cs            |  22 ++---\n mRemoteNG/Tree/Smart/SmartConnectionInfo.cs        |  62 +++++--------\n mRemoteNG/Tree/Smart/SmartGroupRoot.cs             |  15 ++--\n mRemoteNG/UI/Controls/ConnectionContextMenu.cs     |  62 ++++++++++++-\n .../UI/Controls/ConnectionTree/ConnectionTree.cs   |  10 ++-\n 11 files changed, 185 insertions(+), 133 deletions(-)",
      "timestamp": "2026-02-19T20:09:05",
      "diff_output": "diff --git a/.project-roadmap/issues-db/upstream/1250.json b/.project-roadmap/issues-db/upstream/1250.json\nindex 718265993..c51ad8e8c 100644\n--- a/.project-roadmap/issues-db/upstream/1250.json\n+++ b/.project-roadmap/issues-db/upstream/1250.json\n@@ -10,17 +10,24 @@\n   \"created_at\": \"2019-01-04T10:48:34Z\",\n   \"github_updated_at\": \"2019-01-04T13:36:43Z\",\n   \"body_snippet\": \"<!--- Provide a general summary of the issue in the Title above -->\\r\\nIt would be really useful to have a couple of 'smart' connection groups or folders which are separate to the opened connections file. These are most useful when you working with a large number of connections / folders.\\r\\n\\r\\n- Connected - shows all connections currently connected to. Makes it easier to switch to the correct tab when many tabs open\\r\\n- Recent - shows connections recently used (e.g. last 10 or 20). Makes it easier to...\",\n-  \"our_status\": \"new\",\n-  \"priority\": null,\n+  \"our_status\": \"triaged\",\n+  \"priority\": \"P3-enhancement\",\n   \"target_release\": null,\n   \"our_branch\": null,\n   \"our_pr\": null,\n-  \"iterations\": [],\n+  \"iterations\": [\n+    {\n+      \"seq\": 1,\n+      \"date\": \"2026-02-19\",\n+      \"type\": \"triaged\",\n+      \"description\": \"Adding smart connection groups (Connected, Recent) to the tree view enhances navigation and session management efficiency.\"\n+    }\n+  ],\n   \"comments\": [],\n   \"comments_cursor\": \"2019-01-04T13:36:43Z\",\n   \"unread_comments\": 0,\n   \"needs_action\": false,\n   \"waiting_for_us\": false,\n   \"last_synced\": \"2026-02-15T09:52:50Z\",\n-  \"notes\": \"\"\n+  \"notes\": \"AI triage (gemini): Adding smart connection groups (Connected, Recent) to the tree view enhances navigation and session management efficiency.\\nApproach: Implement dynamic tree nodes (Smart Nodes) in the Connection Tree that automatically populate with currently connected sessions and a history of recently used connections, likely updating on connection state change events.\"\n }\ndiff --git a/.project-roadmap/scripts/chain-context/_timeout_history.json b/.project-roadmap/scripts/chain-context/_timeout_history.json\nindex e0ee2bee1..f06f99a56 100644\n--- a/.project-roadmap/scripts/chain-context/_timeout_history.json\n+++ b/.project-roadmap/scripts/chain-context/_timeout_history.json\n@@ -160,7 +160,6 @@\n         685.2\n       ],\n       \"triage\": [\n-        142.3,\n         179.9,\n         122.0,\n         109.1,\n@@ -209,7 +208,8 @@\n         50.5,\n         162.9,\n         137.5,\n-        32.2\n+        32.2,\n+        27.9\n       ]\n     }\n   },\ndiff --git a/mRemoteNG/Config/Serializers/ConnectionSerializers/Xml/XmlConnectionsDocumentCompiler.cs b/mRemoteNG/Config/Serializers/ConnectionSerializers/Xml/XmlConnectionsDocumentCompiler.cs\nindex 40006ab55..0422272ba 100644\n--- a/mRemoteNG/Config/Serializers/ConnectionSerializers/Xml/XmlConnectionsDocumentCompiler.cs\n+++ b/mRemoteNG/Config/Serializers/ConnectionSerializers/Xml/XmlConnectionsDocumentCompiler.cs\n@@ -8,6 +8,7 @@ using mRemoteNG.Container;\n using mRemoteNG.Security;\n using mRemoteNG.Tree;\n using mRemoteNG.Tree.Root;\n+using mRemoteNG.Tree.Smart;\n \n namespace mRemoteNG.Config.Serializers.ConnectionSerializers.Xml\n {\n@@ -29,6 +30,9 @@ namespace mRemoteNG.Config.Serializers.ConnectionSerializers.Xml\n             // If it is a sibling ContainerInfo, we add it as a child of XML root with IsRoot=\"true\".\n             foreach (ContainerInfo root in connectionTreeModel.RootNodes)\n             {\n+                // Skip virtual Smart Group nodes — they are not persisted\n+                if (root is SmartGroupRoot) continue;\n+\n                 if (root is RootNodeInfo)\n                 {\n                     CompileRecursive(root, rootElement);\ndiff --git a/mRemoteNG/Connection/ConnectionInitiator.cs b/mRemoteNG/Connection/ConnectionInitiator.cs\nindex cf6b2d7a6..273be4e92 100644\n--- a/mRemoteNG/Connection/ConnectionInitiator.cs\n+++ b/mRemoteNG/Connection/ConnectionInitiator.cs\n@@ -12,6 +12,7 @@ using mRemoteNG.UI.Tabs;\n using mRemoteNG.UI.Window;\n using WeifenLuo.WinFormsUI.Docking;\n using mRemoteNG.Resources.Language;\n+using mRemoteNG.Tree.Smart;\n using System.Runtime.Versioning;\n \n namespace mRemoteNG.Connection\n@@ -41,6 +42,9 @@ namespace mRemoteNG.Connection\n \n         public bool SwitchToOpenConnection(ConnectionInfo connectionInfo)\n         {\n+            if (connectionInfo is SmartConnectionInfo smartInfo)\n+                connectionInfo = smartInfo.GetOriginal();\n+\n             InterfaceControl? interfaceControl = FindConnectionContainer(connectionInfo);\n             ConnectionTab? connectionTab = interfaceControl?.FindForm() as ConnectionTab;\n \n@@ -87,6 +91,10 @@ namespace mRemoteNG.Connection\n             if (connectionInfo == null)\n                 return;\n \n+            // Unwrap Smart Group proxy to operate on the real connection\n+            if (connectionInfo is SmartConnectionInfo smartInfo)\n+                connectionInfo = smartInfo.GetOriginal();\n+\n             if (connectionInfo.IsTemplate)\n             {\n                 Runtime.MessageCollector.AddMessage(MessageClass.InformationMsg, $\"Connection '{connectionInfo.Name}' is a template and cannot be opened.\");\ndiff --git a/mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs b/mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs\nindex cdbcfbae7..9c7f84ef3 100644\n--- a/mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs\n+++ b/mRemoteNG/Tree/ConnectionTreeDragAndDropHandler.cs\n@@ -6,6 +6,7 @@ using BrightIdeasSoftware;\n using mRemoteNG.Connection;\n using mRemoteNG.Container;\n using mRemoteNG.Tree.Root;\n+using mRemoteNG.Tree.Smart;\n using mRemoteNG.Resources.Language;\n using System.Runtime.Versioning;\n \n@@ -142,7 +143,7 @@ namespace mRemoteNG.Tree\n         private DragDropEffects HandleCanDropOnItem(ConnectionInfo dropSource, ConnectionInfo dropTarget)\n         {\n             DragDropEffects dragDropEffect = DragDropEffects.None;\n-            if (dropTarget is ContainerInfo && !(dropTarget is RootPuttySessionsNodeInfo))\n+            if (dropTarget is ContainerInfo && !(dropTarget is RootPuttySessionsNodeInfo) && !IsSmartGroupContainer(dropTarget))\n             {\n                 if (!IsValidDrag(dropSource, dropTarget)) return dragDropEffect;\n                 dragDropEffect = DragDropEffects.Move;\n@@ -161,7 +162,7 @@ namespace mRemoteNG.Tree\n             DragDropEffects dragDropEffect = DragDropEffects.None;\n             if (AncestorDraggingOntoChild(dropSource, dropTarget))\n                 _infoMessage = Language.NodeCannotDragParentOnChild;\n-            else if (dropTarget is PuttySessionInfo || dropTarget is RootNodeInfo)\n+            else if (dropTarget is PuttySessionInfo || dropTarget is RootNodeInfo || IsSmartGroupContainer(dropTarget) || dropTarget is SmartConnectionInfo)\n                 _enableFeedback = false;\n             else\n             {\n@@ -188,7 +189,11 @@ namespace mRemoteNG.Tree\n \n         private bool NodeIsDraggable(ConnectionInfo node)\n         {\n-            return node != null && !(node is RootNodeInfo) && !(node is PuttySessionInfo);\n+            return node != null\n+                && node is not RootNodeInfo\n+                && node is not PuttySessionInfo\n+                && node is not SmartConnectionInfo\n+                && !IsSmartGroupContainer(node);\n         }\n \n         private bool NodeDraggingOntoSelf(ConnectionInfo source, ConnectionInfo target)\n@@ -206,5 +211,10 @@ namespace mRemoteNG.Tree\n         {\n             return target is ContainerInfo targetAsContainer && targetAsContainer.Children.Contains(source);\n         }\n+\n+        private static bool IsSmartGroupContainer(ConnectionInfo node)\n+        {\n+            return node is SmartGroupRoot or ConnectedGroupNode or RecentGroupNode;\n+        }\n     }\n }\n\\ No newline at end of file\ndiff --git a/mRemoteNG/Tree/Smart/ConnectedGroupNode.cs b/mRemoteNG/Tree/Smart/ConnectedGroupNode.cs\nindex 410412edc..1ff51264c 100644\n--- a/mRemoteNG/Tree/Smart/ConnectedGroupNode.cs\n+++ b/mRemoteNG/Tree/Smart/ConnectedGroupNode.cs\n@@ -5,10 +5,14 @@ using mRemoteNG.App;\n using mRemoteNG.Config.Connections;\n using mRemoteNG.Connection;\n using mRemoteNG.Container;\n-using mRemoteNG.Tree;\n \n namespace mRemoteNG.Tree.Smart\n {\n+    /// <summary>\n+    /// Virtual container that automatically shows all currently connected sessions.\n+    /// Listens to <see cref=\"ConnectionInfo.OpenConnections\"/> changes and maintains\n+    /// a list of <see cref=\"SmartConnectionInfo\"/> wrappers.\n+    /// </summary>\n     [SupportedOSPlatform(\"windows\")]\n     public class ConnectedGroupNode : ContainerInfo\n     {\n@@ -23,99 +27,73 @@ namespace mRemoteNG.Tree.Smart\n             var model = Runtime.ConnectionsService.ConnectionTreeModel;\n             if (model != null)\n             {\n-                // Subscribe to property changes to detect connection status changes\n                 model.PropertyChanged += OnModelPropertyChanged;\n-                \n-                // Initial population\n                 RefreshList();\n             }\n-            \n-            // Also listen if model changes (ConnectionsLoaded event in Runtime?)\n+\n             Runtime.ConnectionsService.ConnectionsLoaded += OnConnectionsLoaded;\n         }\n \n         private void OnConnectionsLoaded(object? sender, ConnectionsLoadedEventArgs e)\n         {\n-             // Re-subscribe if model changed\n-             if (e.NewConnectionTreeModel != null)\n-             {\n-                 e.NewConnectionTreeModel.PropertyChanged -= OnModelPropertyChanged; // Safety\n-                 e.NewConnectionTreeModel.PropertyChanged += OnModelPropertyChanged;\n-                 RefreshList();\n-             }\n+            if (e.NewConnectionTreeModel == null) return;\n+\n+            e.NewConnectionTreeModel.PropertyChanged -= OnModelPropertyChanged;\n+            e.NewConnectionTreeModel.PropertyChanged += OnModelPropertyChanged;\n+\n+            ClearSmartChildren();\n+            RefreshList();\n         }\n \n         private void OnModelPropertyChanged(object? sender, PropertyChangedEventArgs e)\n         {\n-             // We are looking for OpenConnections changes on ConnectionInfo objects\n-             if (sender is ConnectionInfo ci && e.PropertyName == nameof(ConnectionInfo.OpenConnections))\n-             {\n-                 // Check if it's already in our list (to avoid infinite loop if SmartConnectionInfo triggers this)\n-                 // SmartConnectionInfo wraps ConnectionInfo.\n-                 // The sender is the ORIGINAL ConnectionInfo (or SmartConnectionInfo).\n-                 // If sender is SmartConnectionInfo, we ignore it (it's our child).\n-                 if (ci is SmartConnectionInfo) return;\n-\n-                 UpdateConnection(ci);\n-             }\n+            if (sender is not ConnectionInfo ci) return;\n+            if (ci is SmartConnectionInfo) return;\n+            if (e.PropertyName != nameof(ConnectionInfo.OpenConnections)) return;\n+\n+            UpdateConnection(ci);\n         }\n \n         private void RefreshList()\n         {\n-            // Clear children (careful: do not dispose SmartConnectionInfo if we want to reuse? \n-            // For now, recreate. SmartConnectionInfo doesn't hold heavy resources other than event subscription).\n-            // We should unsubscribe SmartConnectionInfo from original when removing!\n-            // SmartConnectionInfo needs Dispose or we rely on GC (event reference might keep it alive).\n-            // Since SmartConnectionInfo subscribes to _original, _original keeps SmartConnectionInfo alive!\n-            // So we MUST Unsubscribe.\n-            // I'll add Dispose to SmartConnectionInfo later or handle it here.\n-            \n-            // Better: Scan all connections and update.\n             var model = Runtime.ConnectionsService.ConnectionTreeModel;\n             if (model == null) return;\n \n             var allConnections = model.GetRecursiveChildList();\n-            \n-            // Remove those that are no longer connected\n+\n+            // Remove stale entries\n             var toRemove = Children.OfType<SmartConnectionInfo>()\n                 .Where(s => s.GetOriginal().OpenConnections.Count == 0 || !allConnections.Contains(s.GetOriginal()))\n                 .ToList();\n-            \n             foreach (var item in toRemove)\n-            {\n                 RemoveChild(item);\n-            }\n \n-            // Add those that are connected and not in list\n-            var connected = allConnections.Where(c => c.OpenConnections.Count > 0 && !(c is SmartConnectionInfo));\n-            foreach (var c in connected)\n+            // Add missing connected entries\n+            foreach (var c in allConnections)\n             {\n-                if (!Children.OfType<SmartConnectionInfo>().Any(s => s.GetOriginal() == c))\n-                {\n-                    AddChild(new SmartConnectionInfo(c));\n-                }\n+                if (c is SmartConnectionInfo) continue;\n+                if (c.OpenConnections.Count == 0) continue;\n+                if (Children.OfType<SmartConnectionInfo>().Any(s => s.GetOriginal() == c)) continue;\n+\n+                AddChild(new SmartConnectionInfo(c));\n             }\n         }\n-        \n+\n         private void UpdateConnection(ConnectionInfo ci)\n         {\n             bool isConnected = ci.OpenConnections.Count > 0;\n             var existing = Children.OfType<SmartConnectionInfo>().FirstOrDefault(s => s.GetOriginal() == ci);\n-            \n-            if (isConnected)\n-            {\n-                if (existing == null)\n-                {\n-                    AddChild(new SmartConnectionInfo(ci));\n-                }\n-            }\n-            else\n-            {\n-                if (existing != null)\n-                {\n-                    RemoveChild(existing);\n-                }\n-            }\n+\n+            if (isConnected && existing == null)\n+                AddChild(new SmartConnectionInfo(ci));\n+            else if (!isConnected && existing != null)\n+                RemoveChild(existing);\n+        }\n+\n+        private void ClearSmartChildren()\n+        {\n+            foreach (var child in Children.OfType<SmartConnectionInfo>().ToList())\n+                RemoveChild(child);\n         }\n     }\n }\ndiff --git a/mRemoteNG/Tree/Smart/RecentGroupNode.cs b/mRemoteNG/Tree/Smart/RecentGroupNode.cs\nindex c6c3ce7a3..252e47aeb 100644\n--- a/mRemoteNG/Tree/Smart/RecentGroupNode.cs\n+++ b/mRemoteNG/Tree/Smart/RecentGroupNode.cs\n@@ -1,14 +1,15 @@\n using System;\n-using System.ComponentModel;\n using System.Linq;\n using System.Runtime.Versioning;\n-using mRemoteNG.App;\n using mRemoteNG.Connection;\n using mRemoteNG.Container;\n-using mRemoteNG.Tree;\n \n namespace mRemoteNG.Tree.Smart\n {\n+    /// <summary>\n+    /// Virtual container that shows recently used connections (last 10).\n+    /// Updated whenever <see cref=\"RecentConnectionsService.RecentConnectionsChanged\"/> fires.\n+    /// </summary>\n     [SupportedOSPlatform(\"windows\")]\n     public class RecentGroupNode : ContainerInfo\n     {\n@@ -26,21 +27,16 @@ namespace mRemoteNG.Tree.Smart\n \n         private void OnRecentConnectionsChanged(object? sender, EventArgs e)\n         {\n-            // Must invoke on UI thread if needed? \n-            // RecentConnectionsService raises event.\n-            // If we manipulate Children, CollectionChanged fires -> UI update.\n-            // This usually happens on UI thread if triggered by UI action.\n             RefreshList();\n         }\n \n         private void RefreshList()\n         {\n-            var recents = RecentConnectionsService.Instance.GetRecentConnections();\n-            \n-            // Rebuild list to match order\n-            Children.Clear();\n-            \n-            foreach (var c in recents)\n+            // Remove existing children properly (unsubscribes events)\n+            foreach (var child in Children.OfType<SmartConnectionInfo>().ToList())\n+                RemoveChild(child);\n+\n+            foreach (var c in RecentConnectionsService.Instance.GetRecentConnections())\n             {\n                 if (c == null) continue;\n                 AddChild(new SmartConnectionInfo(c));\ndiff --git a/mRemoteNG/Tree/Smart/SmartConnectionInfo.cs b/mRemoteNG/Tree/Smart/SmartConnectionInfo.cs\nindex 32f175a49..549ccbbe0 100644\n--- a/mRemoteNG/Tree/Smart/SmartConnectionInfo.cs\n+++ b/mRemoteNG/Tree/Smart/SmartConnectionInfo.cs\n@@ -1,65 +1,51 @@\n using System.ComponentModel;\n using System.Runtime.Versioning;\n using mRemoteNG.Connection;\n-using mRemoteNG.Container;\n-using mRemoteNG.Tree;\n \n namespace mRemoteNG.Tree.Smart\n {\n+    /// <summary>\n+    /// A read-only proxy that mirrors an original <see cref=\"ConnectionInfo\"/>\n+    /// in the Smart Groups tree. Shares <see cref=\"ConnectionInfo.OpenConnections\"/>\n+    /// with the original so connection status is always in sync.\n+    /// </summary>\n     [SupportedOSPlatform(\"windows\")]\n     public class SmartConnectionInfo : ConnectionInfo\n     {\n         private readonly ConnectionInfo _original;\n+        private bool _syncing;\n \n         public SmartConnectionInfo(ConnectionInfo original)\n         {\n             _original = original;\n-            // Copy initial state\n+            _syncing = true;\n             CopyFrom(_original);\n-            \n-            // Share the OpenConnections list so status is shared\n             OpenConnections = _original.OpenConnections;\n+            _syncing = false;\n \n-            // Subscribe to original events to sync changes\n             _original.PropertyChanged += OnOriginalPropertyChanged;\n         }\n \n         private void OnOriginalPropertyChanged(object? sender, PropertyChangedEventArgs e)\n         {\n-            if (string.IsNullOrEmpty(e.PropertyName)) return;\n+            if (string.IsNullOrEmpty(e.PropertyName) || _syncing) return;\n \n-            // Sync property if needed\n-            // For simple properties, CopyFrom might be overkill or recursive if not careful.\n-            // But since we are a separate instance, updating our property is fine.\n-            \n-            // We can't easily know which property changed value without reflection or switch.\n-            // But we can just use CopyFrom for everything, or let the getter handle it?\n-            // No, properties are stored in fields in base class. We must update them.\n-            \n-            // Optimization: Only update the specific property?\n-            // AbstractConnectionRecord doesn't expose a \"SetProperty\" by name easily.\n-            // But it has `GetPropertyValue` / `SetField`.\n-            \n-            // Easier approach: Re-copy everything on any change? Might be slow.\n-            // But PropertyChanged usually happens for one property.\n-            \n-            // Let's try to just CopyFrom for now. It copies all fields.\n-            // Check if CopyFrom triggers PropertyChanged on 'this'.\n-            // AbstractConnectionRecord.CopyFrom uses setters, so yes, it triggers PropertyChanged.\n-            // This is what we want!\n-            \n-            // BUT: Avoid infinite loops if we were somehow bound two-way (we are not).\n-            \n-            // One caveat: CopyFrom might create a NEW OpenConnections list.\n-            // We must restore the shared one if CopyFrom overwrites it.\n-            var sharedConnections = OpenConnections;\n-            CopyFrom(_original);\n-            OpenConnections = sharedConnections; // Restore shared list\n+            _syncing = true;\n+            try\n+            {\n+                var sharedConnections = OpenConnections;\n+                CopyFrom(_original);\n+                OpenConnections = sharedConnections;\n+            }\n+            finally\n+            {\n+                _syncing = false;\n+            }\n         }\n \n-        public ConnectionInfo GetOriginal()\n-        {\n-            return _original;\n-        }\n+        /// <summary>Returns the real connection this proxy represents.</summary>\n+        public ConnectionInfo GetOriginal() => _original;\n+\n+        public override TreeNodeType GetTreeNodeType() => TreeNodeType.Connection;\n     }\n }\ndiff --git a/mRemoteNG/Tree/Smart/SmartGroupRoot.cs b/mRemoteNG/Tree/Smart/SmartGroupRoot.cs\nindex e286b5c48..65c5fe424 100644\n--- a/mRemoteNG/Tree/Smart/SmartGroupRoot.cs\n+++ b/mRemoteNG/Tree/Smart/SmartGroupRoot.cs\n@@ -1,11 +1,12 @@\n-using System.ComponentModel;\n using System.Runtime.Versioning;\n using mRemoteNG.Container;\n-using mRemoteNG.Tree;\n-using mRemoteNG.Resources.Language;\n \n namespace mRemoteNG.Tree.Smart\n {\n+    /// <summary>\n+    /// Virtual root node for Smart Groups in the connection tree.\n+    /// Not persisted to XML or SQL — serializers only process <see cref=\"Tree.Root.RootNodeInfo\"/> nodes.\n+    /// </summary>\n     [SupportedOSPlatform(\"windows\")]\n     public class SmartGroupRoot : ContainerInfo\n     {\n@@ -13,14 +14,8 @@ namespace mRemoteNG.Tree.Smart\n         {\n             Name = \"Smart Groups\";\n             IsExpanded = true;\n-            // Ensure this node is not saved to XML by default serializers\n-            // Serializers usually check for RootNodeInfo or iterate specific roots.\n-            // This is just a ContainerInfo so it behaves like a folder.\n         }\n \n-        public override TreeNodeType GetTreeNodeType()\n-        {\n-            return TreeNodeType.Container;\n-        }\n+        public override TreeNodeType GetTreeNodeType() => TreeNodeType.Container;\n     }\n }\ndiff --git a/mRemoteNG/UI/Controls/ConnectionContextMenu.cs b/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\nindex 6b1cf9d8f..8a5db825b 100644\n--- a/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\n+++ b/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\n@@ -13,6 +13,7 @@ using mRemoteNG.Tools;\n using mRemoteNG.Tools.Clipboard;\n using mRemoteNG.Tree;\n using mRemoteNG.Tree.Root;\n+using mRemoteNG.Tree.Smart;\n using mRemoteNG.Resources.Language;\n using System.Runtime.Versioning;\n using mRemoteNG.Security;\n@@ -677,7 +678,11 @@ namespace mRemoteNG.UI.Controls\n             {\n                 Enabled = true;\n                 EnableMenuItemsRecursive(Items);\n-                if (_connectionTree.SelectedNode is RootPuttySessionsNodeInfo)\n+                if (IsSmartGroupNode(_connectionTree.SelectedNode))\n+                {\n+                    ShowHideMenuItemsForSmartGroupNode(_connectionTree.SelectedNode);\n+                }\n+                else if (_connectionTree.SelectedNode is RootPuttySessionsNodeInfo)\n                 {\n                     ShowHideMenuItemsForRootPuttyNode();\n                 }\n@@ -709,6 +714,61 @@ namespace mRemoteNG.UI.Controls\n             }\n         }\n \n+        private static bool IsSmartGroupNode(ConnectionInfo node)\n+        {\n+            return node is SmartGroupRoot or ConnectedGroupNode or RecentGroupNode or SmartConnectionInfo;\n+        }\n+\n+        internal void ShowHideMenuItemsForSmartGroupNode(ConnectionInfo node)\n+        {\n+            // Smart group nodes are virtual — disable all editing operations\n+            _cMenTreeAddConnection.Enabled = false;\n+            _cMenTreeAddEntity.Enabled = false;\n+            _cMenTreeAddFolder.Enabled = false;\n+            _cMenTreeAddRootFolder.Enabled = false;\n+            _cMenTreeRename.Enabled = false;\n+            _cMenTreeDelete.Enabled = false;\n+            _cMenTreeDuplicate.Enabled = false;\n+            _cMenTreeCreateLink.Enabled = false;\n+            _cMenTreeMoveUp.Enabled = false;\n+            _cMenTreeMoveDown.Enabled = false;\n+            _cMenTreeImport.Enabled = false;\n+            _cMenTreeExportFile.Enabled = false;\n+            _cMenTreeToolsSort.Enabled = false;\n+            _cMenTreeProperties.Enabled = false;\n+            _cMenTreeApplyInheritanceToChildren.Enabled = false;\n+            _cMenTreeApplyDefaultInheritance.Enabled = false;\n+            _cMenTreeConfigureDynamicSource.Visible = false;\n+            _cMenTreeRefreshDynamicSource.Visible = false;\n+\n+            if (node is SmartConnectionInfo smartInfo)\n+            {\n+                // For smart connection items, allow connect/disconnect on the original\n+                bool isConnected = smartInfo.GetOriginal().OpenConnections.Count > 0;\n+                _cMenTreeConnect.Enabled = !isConnected;\n+                _cMenTreeConnectWithOptions.Enabled = !isConnected;\n+                _cMenTreeDisconnect.Enabled = isConnected;\n+                _cMenTreeReconnect.Enabled = isConnected;\n+                _cMenTreeCopyHostname.Enabled = true;\n+            }\n+            else\n+            {\n+                // Smart group containers — no connect actions\n+                _cMenTreeConnect.Enabled = false;\n+                _cMenTreeConnectWithOptions.Enabled = false;\n+                _cMenTreeDisconnect.Enabled = false;\n+                _cMenTreeReconnect.Enabled = false;\n+                _cMenTreeTypePassword.Enabled = false;\n+                _cMenTreeTypeClipboard.Enabled = false;\n+                _cMenTreeToolsTransferFile.Enabled = false;\n+                _cMenTreeToolsWakeOnLan.Enabled = false;\n+                _cMenTreeToolsExternalApps.Enabled = false;\n+                _cMenTreeCopyHostname.Enabled = false;\n+                _cMenTreeConnectWithOptionsAlternativeAddress.Enabled = false;\n+                _cMenTreeConnectWithOptionsViewOnly.Enabled = false;\n+            }\n+        }\n+\n         internal void ShowHideMenuItemsForRootPuttyNode()\n         {\n             _cMenTreeAddConnection.Enabled = false;\ndiff --git a/mRemoteNG/UI/Controls/ConnectionTree/ConnectionTree.cs b/mRemoteNG/UI/Controls/ConnectionTree/ConnectionTree.cs\nindex 39b96dbe6..416618038 100644\n--- a/mRemoteNG/UI/Controls/ConnectionTree/ConnectionTree.cs\n+++ b/mRemoteNG/UI/Controls/ConnectionTree/ConnectionTree.cs\n@@ -500,6 +500,10 @@ namespace mRemoteNG.UI.Controls.ConnectionTree\n                     }\n \n                     if (selectedNode is PuttySessionInfo) continue;\n+                    if (selectedNode is Tree.Smart.SmartConnectionInfo\n+                        || selectedNode is Tree.Smart.SmartGroupRoot\n+                        || selectedNode is Tree.Smart.ConnectedGroupNode\n+                        || selectedNode is Tree.Smart.RecentGroupNode) continue;\n                     if (selectedNode.Parent == null) continue;\n                     if (!NodeDeletionConfirmer.Confirm(selectedNode)) return;\n                     ConnectionTreeModel.DeleteNode(selectedNode);\n@@ -786,7 +790,11 @@ namespace mRemoteNG.UI.Controls.ConnectionTree\n             if (_nodeInEditMode || sender is not ConnectionTree)\n                 return;\n \n-            if (!_allowEdit || SelectedNode is PuttySessionInfo || SelectedNode is RootPuttySessionsNodeInfo)\n+            if (!_allowEdit || SelectedNode is PuttySessionInfo || SelectedNode is RootPuttySessionsNodeInfo\n+                || SelectedNode is Tree.Smart.SmartConnectionInfo\n+                || SelectedNode is Tree.Smart.SmartGroupRoot\n+                || SelectedNode is Tree.Smart.ConnectedGroupNode\n+                || SelectedNode is Tree.Smart.RecentGroupNode)\n             {\n                 e.CancelEdit = true;\n                 return;"
    }
  ],
  "timeout_count": 1,
  "all_timed_out": false,
  "final_success": false
}
