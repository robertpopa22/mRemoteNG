{
  "task_type": "implement",
  "task_id": "874",
  "started_at": "2026-02-17T09:03:46",
  "finished_at": "2026-02-17T09:19:20",
  "attempts": [
    {
      "agent": "gemini",
      "task": "implement #874",
      "success": false,
      "result": null,
      "raw_output": "",
      "errors": "Agent returned None after retries",
      "files_modified": [],
      "build_result": null,
      "test_result": null,
      "timed_out": false,
      "diff_summary": null,
      "timestamp": "2026-02-17T09:14:35"
    },
    {
      "agent": "claude",
      "task": "implement #874",
      "success": false,
      "result": null,
      "raw_output": "",
      "errors": "Build OK but tests failed. Changes left in working tree.",
      "files_modified": [
        ".project-roadmap/issues-db/upstream/0872.json",
        ".project-roadmap/issues-db/upstream/0874.json",
        ".project-roadmap/scripts/chain-context/_timeout_history.json",
        "mRemoteNG/App/Import.cs",
        "mRemoteNG/Config/Import/ActiveDirectoryImporter.cs",
        "mRemoteNG/Config/Import/IConnectionImporter.cs",
        "mRemoteNG/Config/Import/RegistryImporter.cs",
        "mRemoteNG/Connection/ConnectionInitiator.cs",
        "mRemoteNG/Container/ContainerInfo.cs",
        "mRemoteNG/Tree/ClickHandlers/OpenConnectionClickHandler.cs",
        "mRemoteNG/Tree/CommandLineConnectionOpener.cs",
        "mRemoteNG/UI/Controls/ConnectionContextMenu.cs",
        "mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs",
        "mRemoteNG/UI/Window/PortScanWindow.cs"
      ],
      "build_result": "OK",
      "test_result": "FAIL",
      "timed_out": false,
      "diff_summary": ".project-roadmap/issues-db/upstream/0872.json      | 10 ++++-\n .project-roadmap/issues-db/upstream/0874.json      |  8 +++-\n .../scripts/chain-context/_timeout_history.json    | 29 ++++++++++++--\n mRemoteNG/App/Import.cs                            | 12 +++---\n mRemoteNG/Config/Import/ActiveDirectoryImporter.cs |  9 +++--\n mRemoteNG/Config/Import/IConnectionImporter.cs     |  4 +-\n mRemoteNG/Config/Import/RegistryImporter.cs        | 14 ++++---\n mRemoteNG/Connection/ConnectionInitiator.cs        | 12 +++++-\n mRemoteNG/Container/ContainerInfo.cs               |  8 ++++\n .../ClickHandlers/OpenConnectionClickHandler.cs    | 22 +++++++++--\n mRemoteNG/Tree/CommandLineConnectionOpener.cs      |  2 +-\n mRemoteNG/UI/Controls/ConnectionContextMenu.cs     | 45 +++++++++++++++-------\n mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs |  4 +-\n mRemoteNG/UI/Window/PortScanWindow.cs              |  8 ++--\n 14 files changed, 137 insertions(+), 50 deletions(-)",
      "timestamp": "2026-02-17T09:19:20",
      "diff_output": "diff --git a/.project-roadmap/issues-db/upstream/0872.json b/.project-roadmap/issues-db/upstream/0872.json\nindex ed06c9958..e52646777 100644\n--- a/.project-roadmap/issues-db/upstream/0872.json\n+++ b/.project-roadmap/issues-db/upstream/0872.json\n@@ -13,7 +13,7 @@\n   \"created_at\": \"2018-01-25T15:21:21Z\",\n   \"github_updated_at\": \"2026-02-07T19:51:31Z\",\n   \"body_snippet\": \"As we already have the ability to use SQL and AD integration it would be great if we could restrict access at the folder levels.  This would allow the ability to share connections with other members of our teams, but also allow us to restrict who has access to what sections within the application\\r\\n\\r\\nAlso having a local and centralized credentials manager would help as well with this\",\n-  \"our_status\": \"triaged\",\n+  \"our_status\": \"wontfix\",\n   \"priority\": \"P3-enhancement\",\n   \"target_release\": null,\n   \"our_branch\": null,\n@@ -24,6 +24,12 @@\n       \"date\": \"2026-02-16\",\n       \"type\": \"triaged\",\n       \"description\": \"The issue describes a broad folder-level ACL enhancement without reproducible current behavior or concrete requirements validated on the latest build.\"\n+    },\n+    {\n+      \"seq\": 2,\n+      \"date\": \"2026-02-17\",\n+      \"type\": \"wontfix\",\n+      \"description\": \"Major architectural feature requiring SQL ACL schema, AD permission mapping, folder-level filtering, and credential manager — far exceeds current scope and would need dedicated design/sprint\"\n     }\n   ],\n   \"comments\": [\n@@ -51,5 +57,5 @@\n   \"needs_action\": true,\n   \"waiting_for_us\": false,\n   \"last_synced\": \"2026-02-15T09:52:50Z\",\n-  \"notes\": \"AI triage (codex): The issue describes a broad folder-level ACL enhancement without reproducible current behavior or concrete requirements validated on the latest build.\\nApproach: Request retest on v1.79.x and gather specific ACL rules, user roles, and expected UI/DB behavior before implementation.\"\n+  \"notes\": \"AI triage (codex): The issue describes a broad folder-level ACL enhancement without reproducible current behavior or concrete requirements validated on the latest build.\\nApproach: Request retest on v1.79.x and gather specific ACL rules, user roles, and expected UI/DB behavior before implementation.\\nAI triage (claude): Major architectural feature requiring SQL ACL schema, AD permission mapping, folder-level filtering, and credential manager — far exceeds current scope and would need dedicated design/sprint\\nApproach: Deferred — requires new SQL ACL tables, AD group resolution, tree filtering by permissions, and folder-level credential manager. Too large for current release cycle.\"\n }\ndiff --git a/.project-roadmap/issues-db/upstream/0874.json b/.project-roadmap/issues-db/upstream/0874.json\nindex 07c59e192..07a99194e 100644\n--- a/.project-roadmap/issues-db/upstream/0874.json\n+++ b/.project-roadmap/issues-db/upstream/0874.json\n@@ -21,6 +21,12 @@\n       \"date\": \"2026-02-16\",\n       \"type\": \"triaged\",\n       \"description\": \"The request does not define required behavior for inheritance, drag/drop, open-session actions, and serialization when a connection also contains children.\"\n+    },\n+    {\n+      \"seq\": 2,\n+      \"date\": \"2026-02-17\",\n+      \"type\": \"triaged\",\n+      \"description\": \"Enhancement to allow connections to act as containers/folders for other connections, requiring architectural updates to the connection model and tree view logic.\"\n     }\n   ],\n   \"comments\": [\n@@ -39,5 +45,5 @@\n   \"needs_action\": true,\n   \"waiting_for_us\": true,\n   \"last_synced\": \"2026-02-15T09:52:50Z\",\n-  \"notes\": \"AI triage (codex): The request does not define required behavior for inheritance, drag/drop, open-session actions, and serialization when a connection also contains children.\\nApproach: Confirm exact UX and data-model rules for connection-as-folder nodes, then refactor containment logic and update tree interaction handling accordingly.\"\n+  \"notes\": \"AI triage (codex): The request does not define required behavior for inheritance, drag/drop, open-session actions, and serialization when a connection also contains children.\\nApproach: Confirm exact UX and data-model rules for connection-as-folder nodes, then refactor containment logic and update tree interaction handling accordingly.\\nAI triage (gemini): Enhancement to allow connections to act as containers/folders for other connections, requiring architectural updates to the connection model and tree view logic.\\nApproach: Investigate allowing ConnectionInfo objects to maintain a list of child connections and update the TreeView to support rendering/expanding connection nodes as parents.\"\n }\ndiff --git a/.project-roadmap/scripts/chain-context/_timeout_history.json b/.project-roadmap/scripts/chain-context/_timeout_history.json\nindex 9b864d3f2..9a81fef9b 100644\n--- a/.project-roadmap/scripts/chain-context/_timeout_history.json\n+++ b/.project-roadmap/scripts/chain-context/_timeout_history.json\n@@ -20,7 +20,11 @@\n         187.8,\n         308.0,\n         203.1,\n-        144.0\n+        144.0,\n+        212.6,\n+        334.7,\n+        351.9,\n+        267.4\n       ],\n       \"triage\": [\n         24.5,\n@@ -32,7 +36,20 @@\n         78.1,\n         50.0,\n         20.1,\n-        27.8\n+        27.8,\n+        15.8,\n+        113.3,\n+        30.4,\n+        28.5,\n+        68.2,\n+        27.2,\n+        37.7,\n+        28.5,\n+        27.0,\n+        23.0,\n+        37.6,\n+        23.0,\n+        29.6\n       ]\n     },\n     \"gemini\": {\n@@ -71,12 +88,16 @@\n         73.3,\n         98.5,\n         86.4,\n-        112.9\n+        112.9,\n+        32.6\n       ]\n     }\n   },\n   \"escalations\": {\n     \"triage_1083\": 1.5,\n-    \"triage_1086\": 1.5\n+    \"triage_1086\": 1.5,\n+    \"triage_824\": 1.5,\n+    \"triage_859\": 1.5,\n+    \"triage_764\": 1.5\n   }\n }\ndiff --git a/mRemoteNG/App/Import.cs b/mRemoteNG/App/Import.cs\nindex f357dbde4..bc5f293aa 100644\n--- a/mRemoteNG/App/Import.cs\n+++ b/mRemoteNG/App/Import.cs\n@@ -15,7 +15,7 @@ namespace mRemoteNG.App\n     [SupportedOSPlatform(\"windows\")]\n     public static class Import\n     {\n-        public static void ImportFromFile(ContainerInfo importDestinationContainer)\n+        public static void ImportFromFile(ConnectionInfo importDestinationContainer)\n         {\n             try\n             {\n@@ -54,7 +54,7 @@ namespace mRemoteNG.App\n             }\n         }\n \n-        public static void ImportFromRemoteDesktopManagerCsv(ContainerInfo importDestinationContainer)\n+        public static void ImportFromRemoteDesktopManagerCsv(ConnectionInfo importDestinationContainer)\n         {\n             try\n             {\n@@ -87,7 +87,7 @@ namespace mRemoteNG.App\n \n         public static void HeadlessFileImport(\n \t        IEnumerable<string> filePaths,\n-\t        ContainerInfo importDestinationContainer,\n+\t        ConnectionInfo importDestinationContainer,\n \t        ConnectionsService connectionsService,\n \t        Action<string>? exceptionAction = null)\n         {\n@@ -110,7 +110,7 @@ namespace mRemoteNG.App\n \t\t}\n \n         public static void ImportFromActiveDirectory(string ldapPath,\n-                                                     ContainerInfo importDestinationContainer,\n+                                                     ConnectionInfo importDestinationContainer,\n                                                      bool importSubOu)\n         {\n             try\n@@ -128,7 +128,7 @@ namespace mRemoteNG.App\n \n         public static void ImportFromPortScan(IEnumerable<ScanHost> hosts,\n                                               ProtocolType protocol,\n-                                              ContainerInfo importDestinationContainer)\n+                                              ConnectionInfo importDestinationContainer)\n         {\n             try\n             {\n@@ -144,7 +144,7 @@ namespace mRemoteNG.App\n             }\n         }\n \n-        internal static void ImportFromPutty(ContainerInfo selectedNodeAsContainer)\n+        internal static void ImportFromPutty(ConnectionInfo selectedNodeAsContainer)\n         {\n             try\n             {\ndiff --git a/mRemoteNG/Config/Import/ActiveDirectoryImporter.cs b/mRemoteNG/Config/Import/ActiveDirectoryImporter.cs\nindex 0ed5030ae..4ef9f5571 100644\n--- a/mRemoteNG/Config/Import/ActiveDirectoryImporter.cs\n+++ b/mRemoteNG/Config/Import/ActiveDirectoryImporter.cs\n@@ -1,8 +1,9 @@\n-﻿using System;\n+using System;\n using System.Linq;\n using System.Runtime.Versioning;\n using mRemoteNG.App;\n using mRemoteNG.Config.Serializers.MiscSerializers;\n+using mRemoteNG.Connection;\n using mRemoteNG.Container;\n using mRemoteNG.Tools;\n \n@@ -11,12 +12,12 @@ namespace mRemoteNG.Config.Import\n     [SupportedOSPlatform(\"windows\")]\n     public class ActiveDirectoryImporter : IConnectionImporter<string>\n     {\n-        public void Import(string ldapPath, ContainerInfo destinationContainer)\n+        public void Import(string ldapPath, ConnectionInfo destinationContainer)\n         {\n             Import(ldapPath, destinationContainer, false);\n         }\n \n-        public static void Import(string ldapPath, ContainerInfo destinationContainer, bool importSubOu)\n+        public static void Import(string ldapPath, ConnectionInfo destinationContainer, bool importSubOu)\n         {\n             try\n             {\n@@ -25,7 +26,7 @@ namespace mRemoteNG.Config.Import\n                 Tree.ConnectionTreeModel connectionTreeModel = deserializer.Deserialize();\n                 ContainerInfo importedRootNode = connectionTreeModel.RootNodes.First();\n                 if (importedRootNode == null) return;\n-                Connection.ConnectionInfo[] childrenToAdd = importedRootNode.Children.ToArray();\n+                ConnectionInfo[] childrenToAdd = importedRootNode.Children.ToArray();\n                 destinationContainer.AddChildRange(childrenToAdd);\n             }\n             catch (Exception ex)\ndiff --git a/mRemoteNG/Config/Import/IConnectionImporter.cs b/mRemoteNG/Config/Import/IConnectionImporter.cs\nindex 5614c42ec..f8f71e210 100644\n--- a/mRemoteNG/Config/Import/IConnectionImporter.cs\n+++ b/mRemoteNG/Config/Import/IConnectionImporter.cs\n@@ -1,10 +1,10 @@\n-﻿using mRemoteNG.Container;\n+using mRemoteNG.Connection;\n \n namespace mRemoteNG.Config.Import\n {\n     public interface IConnectionImporter<in TSource>\n         where TSource : class\n     {\n-        void Import(TSource source, ContainerInfo destinationContainer);\n+        void Import(TSource source, ConnectionInfo destinationContainer);\n     }\n }\n\\ No newline at end of file\ndiff --git a/mRemoteNG/Config/Import/RegistryImporter.cs b/mRemoteNG/Config/Import/RegistryImporter.cs\nindex 397fc516c..d6ffce9cb 100644\n--- a/mRemoteNG/Config/Import/RegistryImporter.cs\n+++ b/mRemoteNG/Config/Import/RegistryImporter.cs\n@@ -1,7 +1,8 @@\n-﻿using System;\n+using System;\n using System.Runtime.Versioning;\n using Microsoft.Win32;\n using mRemoteNG.App;\n+using mRemoteNG.Connection;\n using mRemoteNG.Container;\n \n namespace mRemoteNG.Config.Import\n@@ -9,12 +10,12 @@ namespace mRemoteNG.Config.Import\n     [SupportedOSPlatform(\"windows\")]\n     internal class RegistryImporter : IConnectionImporter<string>\n     {\n-        public void Import(string regPath, ContainerInfo destinationContainer)\n+        public void Import(string regPath, ConnectionInfo destinationContainer)\n         {\n             Import(regPath, destinationContainer, false);\n         }\n \n-        public static void Import(string regPath, ContainerInfo destinationContainer, bool noop = false)\n+        public static void Import(string regPath, ConnectionInfo destinationContainer, bool noop = false)\n         {\n             try\n             {\n@@ -60,13 +61,14 @@ namespace mRemoteNG.Config.Import\n                                 }\n                                 catch { }\n \n-                                importedNode.AddChild(new Connection.ConnectionInfo()\n+                                importedNode.AddChild(new ConnectionInfo()\n                                 {\n                                     Name = connName,\n                                     Hostname = Hostname,\n                                     Port = Port == 0 ? 22 : Port,\n                                     Protocol = Protocol,\n-                                    Parent = destinationContainer,\n+                                    Parent = destinationContainer, // Should this be importedNode? The logic above sets Parent=destinationContainer but then adds to importedNode?\n+                                    // importedNode.AddChild sets parent to importedNode. So this assignment is overwritten.\n                                     Username = string.IsNullOrEmpty(Username) ? string.Empty : Username\n                                 });\n                             }\n@@ -83,4 +85,4 @@ namespace mRemoteNG.Config.Import\n         }\n \n     }\n-}\n+}\n\\ No newline at end of file\ndiff --git a/mRemoteNG/Connection/ConnectionInitiator.cs b/mRemoteNG/Connection/ConnectionInitiator.cs\nindex 0d699eb17..a743df45c 100644\n--- a/mRemoteNG/Connection/ConnectionInitiator.cs\n+++ b/mRemoteNG/Connection/ConnectionInitiator.cs\n@@ -59,7 +59,17 @@ namespace mRemoteNG.Connection\n             ConnectionInfo.Force force = ConnectionInfo.Force.None,\n             ConnectionWindow? conForm = null)\n         {\n-            if (containerInfo == null || containerInfo.Children.Count == 0)\n+            if (containerInfo == null)\n+                return;\n+\n+            // When a container has a hostname set, connect to it directly (#874)\n+            if (containerInfo.IsConnectable)\n+            {\n+                OpenConnection((ConnectionInfo)containerInfo, force, conForm);\n+                return;\n+            }\n+\n+            if (containerInfo.Children.Count == 0)\n                 return;\n \n             foreach (ConnectionInfo child in containerInfo.Children)\ndiff --git a/mRemoteNG/Container/ContainerInfo.cs b/mRemoteNG/Container/ContainerInfo.cs\nindex 92b408100..afc9769e0 100644\n--- a/mRemoteNG/Container/ContainerInfo.cs\n+++ b/mRemoteNG/Container/ContainerInfo.cs\n@@ -59,6 +59,14 @@ namespace mRemoteNG.Container\n             set { }\n         }\n \n+        /// <summary>\n+        /// Returns true when this container has connection properties set (non-empty Hostname),\n+        /// meaning it can be connected to directly in addition to acting as a folder.\n+        /// This enables the \"connection as folder\" feature (#874).\n+        /// </summary>\n+        [Browsable(false)]\n+        public bool IsConnectable => !string.IsNullOrWhiteSpace(Hostname);\n+\n         public ContainerInfo(string uniqueId)\n             : base(uniqueId)\n         {\ndiff --git a/mRemoteNG/Tree/ClickHandlers/OpenConnectionClickHandler.cs b/mRemoteNG/Tree/ClickHandlers/OpenConnectionClickHandler.cs\nindex 12410431b..8936576d6 100644\n--- a/mRemoteNG/Tree/ClickHandlers/OpenConnectionClickHandler.cs\n+++ b/mRemoteNG/Tree/ClickHandlers/OpenConnectionClickHandler.cs\n@@ -2,6 +2,7 @@\n using System.Runtime.Versioning;\n using System.Windows.Forms;\n using mRemoteNG.Connection;\n+using mRemoteNG.Container;\n \n namespace mRemoteNG.Tree.ClickHandlers\n {\n@@ -21,14 +22,27 @@ namespace mRemoteNG.Tree.ClickHandlers\n         {\n             if (clickedNode == null)\n                 throw new ArgumentNullException(nameof(clickedNode));\n-            if (clickedNode.GetTreeNodeType() != TreeNodeType.Connection &&\n-                clickedNode.GetTreeNodeType() != TreeNodeType.PuttySession) return;\n+\n+            TreeNodeType nodeType = clickedNode.GetTreeNodeType();\n+\n+            // Allow connecting to containers that have a hostname set (#874)\n+            if (nodeType == TreeNodeType.Container && clickedNode is ContainerInfo container && container.IsConnectable)\n+            {\n+                var force = Control.ModifierKeys.HasFlag(Keys.Control)\n+                    ? ConnectionInfo.Force.DoNotJump\n+                    : ConnectionInfo.Force.None;\n+                _connectionInitiator.OpenConnection(clickedNode, force);\n+                return;\n+            }\n+\n+            if (nodeType != TreeNodeType.Connection &&\n+                nodeType != TreeNodeType.PuttySession) return;\n \n             // Ctrl+DoubleClick opens a new connection tab even if one is already open (#397)\n-            var force = Control.ModifierKeys.HasFlag(Keys.Control)\n+            var forceFlags = Control.ModifierKeys.HasFlag(Keys.Control)\n                 ? ConnectionInfo.Force.DoNotJump\n                 : ConnectionInfo.Force.None;\n-            _connectionInitiator.OpenConnection(clickedNode, force);\n+            _connectionInitiator.OpenConnection(clickedNode, forceFlags);\n         }\n     }\n }\n\\ No newline at end of file\ndiff --git a/mRemoteNG/Tree/CommandLineConnectionOpener.cs b/mRemoteNG/Tree/CommandLineConnectionOpener.cs\nindex 50bc4058f..f8239d45f 100644\n--- a/mRemoteNG/Tree/CommandLineConnectionOpener.cs\n+++ b/mRemoteNG/Tree/CommandLineConnectionOpener.cs\n@@ -108,7 +108,7 @@ namespace mRemoteNG.Tree\n                     return false;\n \n                 // Walk up the parent chain and verify each folder segment matches (in reverse)\n-                ContainerInfo? parent = c.Parent;\n+                ConnectionInfo? parent = c.Parent;\n                 for (int i = folderPath.Length - 1; i >= 0; i--)\n                 {\n                     if (parent == null)\ndiff --git a/mRemoteNG/UI/Controls/ConnectionContextMenu.cs b/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\nindex 519b021be..d840925df 100644\n--- a/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\n+++ b/mRemoteNG/UI/Controls/ConnectionContextMenu.cs\n@@ -631,17 +631,36 @@ namespace mRemoteNG.UI.Controls\n \n         internal void ShowHideMenuItemsForContainer(ContainerInfo containerInfo)\n         {\n-            _cMenTreeConnectWithOptionsConnectInFullscreen.Enabled = false;\n-            _cMenTreeConnectWithOptionsConnectToConsoleSession.Enabled = false;\n+            // When a container has a hostname set, it is connectable (#874)\n+            if (containerInfo.IsConnectable)\n+            {\n+                _cMenTreeConnectWithOptionsConnectInFullscreen.Enabled = containerInfo.Protocol == ProtocolType.RDP;\n+                _cMenTreeConnectWithOptionsConnectToConsoleSession.Enabled = containerInfo.Protocol == ProtocolType.RDP;\n+                _cMenTreeConnectWithOptionsViewOnly.Enabled =\n+                    containerInfo.Protocol == ProtocolType.RDP || containerInfo.Protocol == ProtocolType.VNC;\n+                _cMenTreeConnectWithOptionsAlternativeAddress.Enabled =\n+                    !string.IsNullOrWhiteSpace(containerInfo.AlternativeAddress);\n+                _cMenTreeToolsTransferFile.Enabled =\n+                    containerInfo.Protocol == ProtocolType.SSH1 || containerInfo.Protocol == ProtocolType.SSH2;\n+\n+                bool hasOpenConnections = containerInfo.OpenConnections.Count > 0 ||\n+                                          containerInfo.Children.Any(child => child.OpenConnections.Count > 0);\n+                _cMenTreeDisconnect.Enabled = hasOpenConnections;\n+            }\n+            else\n+            {\n+                _cMenTreeConnectWithOptionsConnectInFullscreen.Enabled = false;\n+                _cMenTreeConnectWithOptionsConnectToConsoleSession.Enabled = false;\n+                _cMenTreeConnectWithOptionsViewOnly.Enabled = false;\n+                _cMenTreeConnectWithOptionsAlternativeAddress.Enabled = false;\n+                _cMenTreeToolsTransferFile.Enabled = false;\n \n-            bool hasOpenConnections = containerInfo.Children.Any(child => child.OpenConnections.Count > 0);\n-            _cMenTreeDisconnect.Enabled = hasOpenConnections;\n+                bool hasOpenConnections = containerInfo.Children.Any(child => child.OpenConnections.Count > 0);\n+                _cMenTreeDisconnect.Enabled = hasOpenConnections;\n+            }\n \n-            _cMenTreeToolsTransferFile.Enabled = false;\n             _cMenTreeToolsWakeOnLan.Enabled = WakeOnLan.IsValidMacAddress(containerInfo.MacAddress);\n             _cMenTreeCreateLink.Enabled = false;\n-            _cMenTreeConnectWithOptionsAlternativeAddress.Enabled = false;\n-            _cMenTreeConnectWithOptionsViewOnly.Enabled = false;\n         }\n \n         internal void ShowHideMenuItemsForPuttyNode(PuttySessionInfo connectionInfo)\n@@ -990,36 +1009,36 @@ namespace mRemoteNG.UI.Controls\n \n         private void OnImportFileClicked(object sender, EventArgs e)\n         {\n-            ContainerInfo? selectedNodeAsContainer;\n+            ConnectionInfo? selectedNodeAsContainer;\n             if (_connectionTree.SelectedNode == null)\n                 selectedNodeAsContainer = Runtime.ConnectionsService.ConnectionTreeModel?.RootNodes.First();\n             else\n                 selectedNodeAsContainer =\n-                    _connectionTree.SelectedNode as ContainerInfo ?? _connectionTree.SelectedNode.Parent;\n+                    _connectionTree.SelectedNode ?? _connectionTree.SelectedNode.Parent;\n             if (selectedNodeAsContainer == null) return;\n             Import.ImportFromFile(selectedNodeAsContainer);\n         }\n \n         private void OnImportPuttyClicked(object sender, EventArgs e)\n         {\n-            ContainerInfo? selectedNodeAsContainer;\n+            ConnectionInfo? selectedNodeAsContainer;\n             if (_connectionTree.SelectedNode == null)\n                 selectedNodeAsContainer = Runtime.ConnectionsService.ConnectionTreeModel?.RootNodes.First();\n             else\n                 selectedNodeAsContainer =\n-                    _connectionTree.SelectedNode as ContainerInfo ?? _connectionTree.SelectedNode.Parent;\n+                    _connectionTree.SelectedNode ?? _connectionTree.SelectedNode.Parent;\n             if (selectedNodeAsContainer == null) return;\n             Import.ImportFromPutty(selectedNodeAsContainer);\n         }\n \n         private void OnImportRemoteDesktopManagerClicked(object sender, EventArgs e)\n         {\n-            ContainerInfo? selectedNodeAsContainer;\n+            ConnectionInfo? selectedNodeAsContainer;\n             if (_connectionTree.SelectedNode == null)\n                 selectedNodeAsContainer = Runtime.ConnectionsService.ConnectionTreeModel?.RootNodes.First();\n             else\n                 selectedNodeAsContainer =\n-                    _connectionTree.SelectedNode as ContainerInfo ?? _connectionTree.SelectedNode.Parent;\n+                    _connectionTree.SelectedNode ?? _connectionTree.SelectedNode.Parent;\n             if (selectedNodeAsContainer == null) return;\n             Import.ImportFromRemoteDesktopManagerCsv(selectedNodeAsContainer);\n         }\ndiff --git a/mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs b/mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs\nindex dfaf41775..f62fb4fd7 100644\n--- a/mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs\n+++ b/mRemoteNG/UI/Window/ActiveDirectoryImportWindow.cs\n@@ -48,9 +48,9 @@ namespace mRemoteNG.UI.Window\n         private void BtnImport_Click(object sender, EventArgs e)\n         {\n             Connection.ConnectionInfo? selectedNode = AppWindows.TreeForm?.SelectedNode;\n-            ContainerInfo? importDestination;\n+            Connection.ConnectionInfo? importDestination;\n             if (selectedNode != null)\n-                importDestination = selectedNode as ContainerInfo ?? selectedNode.Parent;\n+                importDestination = selectedNode;\n             else\n                 importDestination = Runtime.ConnectionsService.ConnectionTreeModel?.RootNodes.First();\n \ndiff --git a/mRemoteNG/UI/Window/PortScanWindow.cs b/mRemoteNG/UI/Window/PortScanWindow.cs\nindex a6d27e350..090f8fdb9 100644\n--- a/mRemoteNG/UI/Window/PortScanWindow.cs\n+++ b/mRemoteNG/UI/Window/PortScanWindow.cs\n@@ -295,7 +295,7 @@ namespace mRemoteNG.UI.Window\n                 return;\n             }\n \n-            ContainerInfo? destinationContainer = GetDestinationContainerForImportedHosts();\n+            ConnectionInfo? destinationContainer = GetDestinationContainerForImportedHosts();\n             if (destinationContainer is null)\n                 return;\n             Import.ImportFromPortScan(hosts, protocol, destinationContainer);\n@@ -305,7 +305,7 @@ namespace mRemoteNG.UI.Window\n         /// Determines where the imported hosts will be placed\n         /// in the connection tree.\n         /// </summary>\n-        private ContainerInfo? GetDestinationContainerForImportedHosts()\n+        private ConnectionInfo? GetDestinationContainerForImportedHosts()\n         {\n             ConnectionInfo? selectedNode = AppWindows.TreeForm?.SelectedNode ?? AppWindows.TreeForm?.ConnectionTree.ConnectionTreeModel.RootNodes.OfType<RootNodeInfo>().First();\n \n@@ -317,8 +317,8 @@ namespace mRemoteNG.UI.Window\n                 selectedNode = AppWindows.TreeForm!.ConnectionTree.ConnectionTreeModel.RootNodes.OfType<RootNodeInfo>()\n                                       .First();\n \n-            // if the selected node is a connection, use its parent container\n-            ContainerInfo? selectedTreeNodeAsContainer = selectedNode as ContainerInfo ?? selectedNode.Parent;\n+            // if the selected node is a connection, use it (it acts as container)\n+            ConnectionInfo? selectedTreeNodeAsContainer = selectedNode;\n \n             return selectedTreeNodeAsContainer;\n         }",
      "test_output": "=== mRemoteNG Test Runner ===\nCPU: 48 logical processors\nTimeout: 15000ms per test\nMode: Full parallel (5 processes)\n\nCleaning stale processes...\nERROR: Test DLL not found at D:\\github\\mRemoteNG\\mRemoteNGTests\\bin\\x64\\Release\\mRemoteNGTests.dll\n\n"
    }
  ],
  "timeout_count": 0,
  "all_timed_out": false,
  "final_success": false
}
